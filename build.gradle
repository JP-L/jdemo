/*
 * Build file for the Demo application
 */
plugins {
    //id "com.jfrog.artifactory" version "4.4.3"
    id "org.sonarqube" version "2.0.1"
    id "com.bmuschko.docker-java-application" version "3.0.1"
    id "net.saliman.cobertura" version "2.3.2"
}
    
/* 
 * Apply plugins to add support for:
 * - Java
 * - Eclipse support
 * - Building a war file to deploy in a servlet engine
 */
apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'eclipse'
apply plugin: 'eclipse-wtp'
apply plugin: "net.saliman.cobertura"
apply plugin: 'com.bmuschko.docker-remote-api'

/* JDK version source compatibility */
sourceCompatibility = 1.8
/* project version */
version = '1.3'
/* War file name */
war.baseName = "${name}"
war.archiveName = "${name}.war"
/* Web directory, this overrides the default value "webapp" */
//project.webAppDirName = 'WebContent'

eclipse {
    project.natures 'org.eclipse.buildship.core.gradleprojectnature'
}

/* ===== Repositories ===== */    
repositories {
    jcenter()
}

/* ===== Artifactory configuration ===== */
artifactory {
    contextUrl = "${artifactory_contextUrl}"   //The base Artifactory URL if not overridden by the publisher/resolver
    publish {
        repository {
            repoKey = 'libs-snapshot-local'
            username = "${artifactory_user}"
            password = "${artifactory_password}"
            maven = true
            
        }
    }
    resolve {
    	repository {
      		repoKey = 'jcenter' // The Artifactory (preferably virtual) repository key to resolve from
      		username = "${artifactory_user}" // Optional resolver user name (leave out to use anonymous resolution)
      		password = "${artifactory_password}" // The resolver password
      		maven = true     
    	}
  	}
}

/* ===== Static Code Analysis ===== */
sonarqube {
  properties {
    property "sonar.projectName", "${name}"
    property "sonar.projectKey", "org.sonarqube:java-gradle-simple"
    property "sonar.cobertura.reportPath","${projectDir}/shippable/codecoverage/coverage.xml"
    property "sonar.junit.reportsPath","${projectDir}/shippable/testresults"
  }
}
/* ===== Unit testing ===== */
test {
    reports.junitXml.destination = "${projectDir}/shippable/testresults"  
    reports.html.destination = "${projectDir}/shippable/testresults"
}
// ===== Code Coverage Analysis =====
cobertura {
    coverageFormats = ['html', 'xml']				
    coverageReportDir = file("${projectDir}/shippable/codecoverage")	
}
test.finalizedBy(project.tasks.cobertura)

/* ===== Docker configuration ===== */
import com.bmuschko.gradle.docker.tasks.image.*

//def dockerRepo = "${awsRegistryUrl}/${name}"
def dockerRepo = "${artifactoryRegistryUrl}/${name}"

docker {
    if (System.env.DOCKER_HOST) {
        url = "$System.env.DOCKER_HOST".replace("tcp","https")
        
        if (System.env.DOCKER_CERT_PATH) {
            certPath = new File(System.env.DOCKER_CERT_PATH)
        }
    }
    else {
        url = 'unix:///var/run/docker.sock'
    }
    																	       
    //registryCredentials {
    //    url = "${awsRegistryUrl}"
    //    username = "${awsRegistryCredentialsUsername}"
    //    password = "${awsRegistryCredentialsPassword}"
    //    //aws ecr get-login --region eu-west-1
    //    email = "${awsRegistryCredentialsEmail}"
    //}
    registryCredentials {
        url = "${artifactoryRegistryUrl}"
        username = "${artifactoryRegistryCredentialsUsername}"
        password = "${artifactoryRegistryCredentialsPassword}"
        email = "${artifactoryRegistryCredentialsEmail}"
    }
}
task copyFiles(type: Copy) {
    from        "${getProject().getBuildDir()}/libs/"
    from        "./src/main/docker/Dockerfile"
    from				"./src/main/resources/docker/setenv.sh"
    into        "${getProject().getBuildDir()}/docker"
}
task buildDockerFile(type: DockerBuildImage) {
    dependsOn   'copyFiles'
    inputDir = file("${getProject().getBuildDir()}/docker")
    tag = "${dockerRepo}" //tag was:  "jpl/demo-application"
}
task tagDockerImage(type: DockerTagImage) {
    //dependsOn buildDockerFile
    force = true
    imageId = buildDockerFile.getTag() // imageId was: targetImageId { buildDockerFile.getImageId() }
    repository = "${dockerRepo}"
    tag = version  
}
task pushDockerImage(type: DockerPushImage) {
    dependsOn tagDockerImage
    imageName = "${dockerRepo}"
    tag = version 
}

/*
 * In this section declare the dependencies for production and test code
 */
dependencies {
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.21'
    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
    
    // Other
    providedCompile 'com.sun.faces:jsf-api:2.2.9'  
    providedCompile 'com.sun.faces:jsf-impl:2.2.9' 
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
    compile 'javax.persistence:persistence-api:1.0.2'
    compile 'org.prevayler:prevayler-factory:2.6'
    compile 'org.prevayler:prevayler-core:2.6'
    compile 'joda-time:joda-time:2.9.3'
    compile 'commons-beanutils:commons-beanutils:1.9.2'
    compile 'org.apache.commons:commons-lang3:3.4'

    // Declare the dependency for a test framework to use in the tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile group: 'junit', name: 'junit', version: '4.+'
    testCompile 'org.hamcrest:hamcrest-junit:2.0.0.0'
    testCompile group: 'info.cukes', name: 'cucumber-java', version: '1.2.+'
    testCompile group: 'info.cukes', name: 'cucumber-junit', version: '1.2.+'
    
    //testCompile 'junit:junit:4.12'
	    
    // The production code uses the SLF4J Java util logging at runtime
    runtime 'org.slf4j:slf4j-jdk14:1.7.21'
    // The production code uses the glassfish impl of JSF
    runtime 'org.glassfish:javax.faces:2.2.9' //Required for Tomcat
}
