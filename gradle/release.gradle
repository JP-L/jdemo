/*
 * Release configuration
 */

/* ==== Apply plugins ==== */
//apply plugin: "maven"

scmVersion {
	repository {
		type = 'git' // type of repository
        directory = project.rootProject.file('./') // repository location
        remote = 'origin' // remote name

        // Authorization
        //customUsername = ""//TODO:get from shippable environment
        //customKey = 'AAasaDDSSD...' //or project.file('myKey') // custom authorization key (file or String)
        //customKeyPassword = 'secret' // key password
    }
    
    tag {
        prefix = "release"
        //initialVersion = { tag: '1.0.0' } // returns initial version if none found, 0.1.0 by default
    }
    
	// Dry run & local only release
    localOnly = "${release_dryrun}" // never connect to remote when true
    // Uncommitted changes
    ignoreUncommittedChanges = true // should uncommitted changes force version bump
    // :doc`use_highest_version`
    useHighestVersion = true // Defaults as false, setting to true will find the highest visible version in the commit tree
    // Sanitization
    sanitizeVersion = true // should created version be sanitized, true by default
    
    branchVersionCreator = [
    	'development/.*' : 'simple',
        'releases/.*' : 'incrementPrerelease',
        'bugfix/.*' : 'simple',
        'master/.*' : 'simple'        
    ]
    
    branchVersionIncrementer = [
        'development/.*' : 'simple',
        'releases/.*' : 'incrementPrerelease',
        'bugfix/.*' : { c -> c.currentVersion.incrementPatchVersion() },
        'master/.*' : 'incrementMinor'
    ]
    
    // Release hooks
    createReleaseCommit true // should create empty commit to annotate release in commit history, false by default
    //releaseCommitMessage { version, position -> ... } // custom commit message if commits are created

    // Pre-release checks
    checks {
        uncommittedChanges = false // permanently disable uncommitted changes check
        aheadOfRemote = false // permanently disable ahead of remote check
    }
    
    hooks {
        pre 'fileUpdate', [file: 'README.md', pattern: {v,p -> /(version.) $v/}, replacement: {v, p -> "\$1 $v"}]
        pre 'commit'
    }
}

def merge(def branchFrom, def branchTo, def stage) {
		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace()
    	println "called by " + stackTraceElements[2].getMethodName()
    return tasks.create("merge${stage}") {
        outputs.upToDateWhen { false } // Make sure this tasks always run
    	doLast {
		    // Check if the release branch exists
	    	if ( grgit.branch.list().find{it.name == "${branchTo}"} != null ) {
	    		println "Merge any changes in ${branchTo} into ${branchFrom} and then checkout branch ${branchTo}"
	    		grgit.merge(head: "${branchTo}", mode: "only-ff", message: "Merged ${branchTo} branch into ${branchFrom} branch")
	    		grgit.checkout(branch: "${branchTo}")
	    	} else {
	    		println "Checkout new branch ${branchTo} based on ${branchFrom}"
	    		grgit.checkout(branch: "${branchTo}", createBranch: true, startPoint: "${branchFrom}")
	    	}
	    	//assuming the merge was successful we can now merge branchFrom into branchTo
	    	println "merge branch ${branchFrom} into ${branchTo}"
			grgit.merge(head: "${branchFrom}", mode: "create-commit", message: "Merged ${branchFrom} branch into ${branchTo} branch")
			// Push the changes upstream
			println "push upstream"
			//grgit.push(remote: "origin", refsOrSpecs: ["+${branchTo}"], force: true, dryRun: "${release_dryrun}")
			grgit.push(remote: "origin", refsOrSpecs: ["refs/heads/${branchTo}:refs/heads/${branchTo}"], force: true, dryRun: "${release_dryrun}")
			// Checkout original branch
			println "checkout starting branch"
			grgit.checkout(branch: "${branchFrom}")
		}
    }
}
task releaseDevelopment {
    description "Merge development branch into release branch"
    outputs.upToDateWhen { false } //Make sure this task always runs
    doLast {
		merge("development","releases", "Development").execute()
	}
}
task releaseMilestone {
	description "Tag releases branch with a milestone version"
	doLast {
    	// Tag releases branch [release-x.x.x-milestone.y]
    }
}
task releaseCandidate {
	description "Merge releases branch into master branch"
	doLast {
    	merge("releases","master", "dev-stage-1").execute()
    	// Tag releases branch [release-x.x.x-rc.y]
    }
}
task releaseVersion {
    // Tag master branch [release-x.x.x], push docker image to DockerHub and deploy to production. 
	//dependsOn .... masterCI and test. When deploy to production a healthcheck is included.
}
