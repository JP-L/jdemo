/*
 * Copyright (c) 2018 JP-L, https://www.jp-l.org/
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Test configuration
 */
buildscript {
    repositories {
    	jcenter()
    	maven {
    		url "https://plugins.gradle.org/m2/"
    	}
        // Activate below when using Artifacotry or Nexus
        //maven {
	    //    url "${binrepo_url}/jcenter/"
	    //    credentials {
	    //   		username "${binrepo_user}"
	    //   		password "${binrepo_password}"
	    //	}
	    //}
    }
    dependencies {
        classpath "com.testingbot:TestingBotTunnel:2.4"
    }
}

/* ==== Apply plugins ==== */
apply plugin: "net.saliman.cobertura"
apply plugin: "org.sonarqube"

/* ==== Add Selenium ==== */
sourceSets {
	selenium {
		java.srcDirs = ["${projectDir}/src/test/docker"]
    	// So that we can compile against the libs used by the unit test classes
        compileClasspath += test.compileClasspath
        // So that test- and business classes can be used at runtime:
        runtimeClasspath += test.runtimeClasspath
  	}
}

/* ===== Unit testing ===== */
test {
    reports.junitXml.destination = file("${projectDir}/shippable/testresults")  
    reports.html.destination = file("${projectDir}/shippable/testresults")
}
// ===== Code Coverage Analysis =====
cobertura {
	description "Analyze code coverage"
	group "Quality"
    coverageFormats = ['html', 'xml']				
    coverageReportDir = file("${projectDir}/shippable/codecoverage")	
}
test.finalizedBy(project.tasks.cobertura)

/* ===== Static Code Analysis ===== */
sonarqube {
	description "Analyze static code"
	group "Quality"
	properties {
		property "sonar.projectName", "${name}"
    	property "sonar.projectKey", "org.sonarqube:jdemo"
    	property "sonar.cobertura.reportPath","${projectDir}/shippable/codecoverage/coverage.xml"
    	property "sonar.junit.reportsPath","${projectDir}/shippable/testresults"
  	}
}

/* ===== CodeCoverage.io ===== */
task codeCovIO(type: Exec) {
	description "Upload code coverage results to CodeCov"
	group "Quality"
    commandLine "/bin/bash", "-c", "bash <(curl -s https://codecov.io/bash) -f ./shippable/codecoverage/coverage.xml"
    ignoreExitValue true
    doLast {
    	def msg = (execResult == 0) ? "SUCCESS: Upload to codeCovIO" : "FAILED: Upload to codeCovIO"
        println "${msg}"
    }
}
/* ==== Tasks ==== */
task inspectQuality(type: GradleBuild) {
	group "Quality"
    tasks = ['test', 'cobertura', 'sonarqube', 'codeCovIO']
}

/* ==== Testingbot tasks ==== */
class ExecWait extends DefaultTask {
	String command
    String ready
    String directory
    Boolean runMode
 
    @TaskAction
    def spawnProcess() {
 
 		if (runMode) {
        	ProcessBuilder builder = new ProcessBuilder(command.split(' '))
        	builder.redirectErrorStream(true)
        	println "${directory}"
	        builder.directory(new File(directory))
	        Process process = builder.start()
	 
	        InputStream stdout = process.getInputStream()
	        BufferedReader reader = new BufferedReader(new InputStreamReader(stdout))
	 
	        def line
	        while ((line = reader.readLine()) != null) {
	            println line
	            if (line.contains(ready)) {
	                println "$command is ready"
	                break;
	            }
	        }
		}
    }
}

task startTestingBotTunnel(type: ExecWait) {
	description "Start TestingBot Tunnel to provide a secure way to run tests against staged/internal webapps."
	group "Test"
	command "java -jar ${testbot_jar} ${testbot_key} ${testbot_secret}"
    ready "INFO: To stop the tunnel, press CTRL+C"
    directory "${getRootProject().getRootDir()}"
    runMode project.getProperty("runMode") == "local"
}
task stopTestingBotTunnel(type: Exec) {
	description "stop TestingBot Tunnel."
	group "Test"
	onlyIf {
        project.getProperty("runMode") == "local"
    }
    
    commandLine "/bin/bash", "-c", "rm testingbot-tunnel.pid"
    //ignoreExitValue true
    
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
		return standardOutput.toString()
	}
}

task runFunctionalAndIntegrationTests(type: Test, dependsOn: ['startDockerContainer', 'startTestingBotTunnel']) {
	description "Run functional and integration tests"
	group "Test"
    finalizedBy stopDockerContainer, stopTestingBotTunnel
    doFirst {
    	systemProperty "webapp_url", project.getProperty("webapp_url")
    	systemProperty "key", project.getProperty("testbot_key")
    	systemProperty "secret", project.getProperty("testbot_secret")
    	systemProperty "runMode", project.getProperty("runMode")
    	systemProperty "stage", project.getProperty("stage")
    	println "Testing URL ${webapp_url}"
    }
    testClassesDir = sourceSets.selenium.output.classesDir
    classpath = sourceSets.selenium.runtimeClasspath
}

task runAcceptanceAndSmokeTests(type: Exec) {
	group "Test"
	//dependsOn .... releaseCI -> probably this becomes a shippable Job
}

/*
 * In this section declare the dependencies for production and test code
 */
dependencies {
    // Declare the dependency for a test framework to use in the tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile 'org.junit.jupiter:junit-jupiter-api:5.1.0'
    testCompile 'org.junit.jupiter:junit-jupiter-engine:5.1.0'
    
    testCompile 'org.hamcrest:hamcrest-junit:2.0.0.0'
    /* Cucumber */
    testCompile group: 'info.cukes', name: 'cucumber-java', version: '1.2.+'
    testCompile group: 'info.cukes', name: 'cucumber-junit', version: '1.2.+'
    /* Selenium */
    seleniumCompile 'org.seleniumhq.selenium:selenium-java:2.33.0'
}
