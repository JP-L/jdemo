/*
 * Release configuration
 */

/* ==== Apply plugins ==== */
//apply plugin: "maven"
buildscript {
    repositories {
        maven {
	        url "${binrepo_url}/jcenter/"
	        //url "${binrepo_url}" https://binaryrepository.jfrog.io/binaryrepository/jcenter/
	        credentials {
	       		username "${binrepo_user}"
	       		password "${binrepo_password}"
	    	}
	    }
    }
    dependencies {
        classpath "pl.allegro.tech.build:axion-release-plugin:1.8.3"
    }
}

import pl.allegro.tech.build.axion.release.domain.VersionConfig
import pl.allegro.tech.build.axion.release.infrastructure.di.GradleAwareContext

scmVersion {
	// Dry run & local only release
    localOnly = "${release_dryrun}" // never connect to remote when true
    // Uncommitted changes
    ignoreUncommittedChanges = true // should uncommitted changes force version bump
    // :doc`use_highest_version`
    useHighestVersion = true // Defaults as false, setting to true will find the highest visible version in the commit tree
    // Sanitization
    sanitizeVersion = true // should created version be sanitized, true by default

	repository {
		type = 'git' // type of repository
        directory = project.rootProject.file('./') // repository location
        remote = 'origin' // remote name

        // Authorization
        //customUsername = ""//TODO:get from shippable environment
        //customKey = 'AAasaDDSSD...' //or project.file('myKey') // custom authorization key (file or String)
        //customKeyPassword = 'secret' // key password
    }
    
    tag {
    	prefix = ''
        //initialVersion(prefix: "", separator: "-", tag: "1.0.0")
    }
        
    //nextVersion {
    	//suffix = 'milestone'
    	//branchSuffix = [
        //    'development/.*' : 'milestone',
        //	'releases/.*' : 'alpha',
        //	'bugfix/.*' : '',
        //	'master/.*' : ''
        //]
        //separator = '-'
    //}
    
    branchVersionCreator = [
    	'development/.*' : 'simple',
        'releases/.*' : 'incrementPrerelease',
        'bugfix/.*' : 'simple',
        'master/.*' : 'simple'        
    ]
    
    branchVersionIncrementer = [
        'development/.*' : 'incrementPatch',
        'releases/.*' : 'incrementPrerelease',
        'bugfix/.*' : { c -> c.currentVersion.incrementPatchVersion() },
        'master/.*' : 'incrementMinor'
    ]
    
    // Release hooks
    createReleaseCommit true // should create empty commit to annotate release in commit history, false by default
    //releaseCommitMessage { version, position -> ... } // custom commit message if commits are created

    // Pre-release checks
    checks {
        uncommittedChanges = false // permanently disable uncommitted changes check
        aheadOfRemote = false // permanently disable ahead of remote check
    }
    
    hooks {
        pre 'fileUpdate', [file: 'README.md', pattern: {v,p -> /(version.) $v/}, replacement: {v, p -> "\$1 $v"}]
        pre 'commit'
    }
}

def merge(def branchFrom, def branchTo, def stage) {
		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace()
    	println "called by " + stackTraceElements[2].getMethodName()
    return tasks.create("merge${stage}") {
    	doLast {
		    // Check if the release branch exists
	    	if ( grgit.branch.list().find{it.name == "${branchTo}"} != null ) {
	    		println "Checkout branch ${branchTo}"
	    		grgit.checkout(branch: "${branchTo}")
	    	} else {
	    		println "Checkout new branch ${branchTo} based on ${branchFrom}"
	    		grgit.checkout(branch: "${branchTo}", createBranch: true, startPoint: "${branchFrom}")
	    	}
	    	//assuming the merge was successful we can now merge branchFrom into branchTo
	    	println "merge branch ${branchFrom} into ${branchTo}"
			grgit.merge(head: "${branchFrom}", mode: "create-commit", message: "Merged ${branchFrom} branch into ${branchTo} branch")
			// Push the changes upstream
			println "push upstream"
			if ("${release_dryrun}" == true) {
				grgit.push(remote: "origin", refsOrSpecs: ["+${branchTo}"], force: true, dryRun: true)
			} else {
				grgit.push(remote: "origin", refsOrSpecs: ["${branchTo}"], force: true)
			}
			// Checkout original branch
			println "checkout starting branch"
			grgit.checkout(branch: "${branchFrom}")
		}
    }
}
def setVersion(def phaseLCM, def successfulTest) {
	// If a branch has no tags yet version defaults to SNAPSHOT.
	// We like to change that behavior and set it to:
	// - on development branch set to: milestone
	// - on release branch set to:     alpha
	// - on master branch set to:      version (fx 1.0.0)
	// If a new version is configured in gradle.properties (major number increased) we
	// like to change behavior to:
	// - on development branch set to: incrementMajor
	// - on release branch set to:     incrementMajor + -alpha
	// - on master branch set to:      incrementMajor
	// If the development branch integration and functional testing is successful
	// we set version to incrementPatch (still using milestone). So:
	// - on development branch set to: incrementPatch (fx 1.0.1-milestone)
	// If the release branch is feature complete and acceptance testing is successful
	// we like to set the version to beta. So:
	// - on release branch set to:     beta           (fx 1.0.0-beta)
	// - otherwise we tag as alpha:    incrementPatch (fx 1.0.1-alpha)
	// If the release branch is feature complete, acceptance testing and smoke testing are successful
	// we like to set the version to RC. So:
	// - on release branch set to:     RC			 (fx 1.0.0-rc2)
	// - otherwise we tag as beta:    incrementPatch (fx 1.0.1-beta)
	// If the release branch is feature complete, acceptance testing and smoke testing are successful,
	// but failed the manual tests we stay on RC, and all patches combined become the next rc. So:
	// - on release branch set to:     incrementPrerelease (fx 1.0.0-rc2)
	// If the master branch verification tests are successful
	// we like to set the version to next version. So:
	// - on master branch set to:      incrementMajor
	switch(phaseLCM){
		case "development":
			if ( "${scmVersion.version}".contains("SNAPSHOT") || "${scmVersion.version}".take(5) < "${release_version}" ) {
				project.ext."release.version" = "${release_version}-milestone"
			} else {
				project.ext."release.version" = "incrementPatch"
        		markNextVersion.execute()
			}
			break
		case "release":
			switch(scmVersion.version) {
				case { ~/.*SNAPSHOT.*/  || it.take(5) < "${release_version}" }:
					project.ext."release.version" = "${release_version}-alpha"
					break
				case ~/.*alpha.*/:
					project.ext."release.version" = "incrementPatch"
        			markNextVersion.execute()
					break
				case ~/.*beta.*/:
					if (successfulTests) {
						project.ext."release.version" = "${release_version}-beta"
					} else {
						project.ext."release.version" = "incrementPatch"
        				markNextVersion.execute()
					}
					break
				case ~/.*RC.*/:
					if (successfulTests) {
						project.ext."release.version" = "${release_version}-RC1" //incrementPrerelease??
					} else {
						project.ext."release.version" = "incrementPrerelease"
        				markNextVersion.execute()
					}
					break
			}
			break
		case "master":
			if ( "${scmVersion.version}".contains("SNAPSHOT") ) {
				project.ext."release.version" = "${release_version}"
			} else {
				project.ext."release.version" = "incrementMajor"
        		markNextVersion.execute()
			}
			break
	}
    release.execute()
}

task releaseDevelopment {
    description "Merge development branch into release branch"
    doLast {
        setVersion("development", null)
		//merge("development","releases", "Development").execute()
	}
}
task releaseAlpha {
	description "Tag releases branch with a alpha version"
	doLast {
	    setVersion("release", null)
		merge("development","releases", "alpha").execute()
    }
}
task releaseBeta1 {
	description "Tag releases branch with a Beta version"
	doLast {
	    setVersion("release", true)
		merge("development","releases", "beta").execute()
    }
}
task releaseBeta2 {
	description "Tag releases branch with a Beta version"
	doLast {
	    setVersion("release", false)
		merge("development","releases", "beta").execute()
    }
}
task releaseCandidate1 {
	description "Merge releases branch into master branch"
	doLast {
	    setVersion("release", true)
    	//merge("releases","master", "RC").execute()
    }
}
task releaseCandidate2 {
	description "Merge releases branch into master branch"
	doLast {
	    setVersion("release", false)
    	//merge("releases","master", "RC").execute()
    }
}
task releaseVersion {
	description "Tag master branch and publish"
	doLast {
	    setVersion("master", null)
	    // push to dockerHub
	    //TODO
	    // deploy into production and run a healthcheck
	    //TODO
    }
}
